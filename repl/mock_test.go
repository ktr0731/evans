// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repl

import (
	"github.com/ktr0731/evans/grpc"
	"github.com/ktr0731/evans/idl"
	"sync"
)

var (
	lockSpecMockFormatDescriptor sync.RWMutex
	lockSpecMockRPC              sync.RWMutex
	lockSpecMockRPCs             sync.RWMutex
	lockSpecMockResolveSymbol    sync.RWMutex
	lockSpecMockServiceNames     sync.RWMutex
)

// Ensure, that SpecMock does implement idl.Spec.
// If this is not the case, regenerate this file with moq.
var _ idl.Spec = &SpecMock{}

// SpecMock is a mock implementation of idl.Spec.
//
//     func TestSomethingThatUsesSpec(t *testing.T) {
//
//         // make and configure a mocked idl.Spec
//         mockedSpec := &SpecMock{
//             FormatDescriptorFunc: func(v any) (string, error) {
// 	               panic("mock out the FormatDescriptor method")
//             },
//             RPCFunc: func(svcName string, rpcName string) (*grpc.RPC, error) {
// 	               panic("mock out the RPC method")
//             },
//             RPCsFunc: func(svcName string) ([]*grpc.RPC, error) {
// 	               panic("mock out the RPCs method")
//             },
//             ResolveSymbolFunc: func(symbol string) (any, error) {
// 	               panic("mock out the ResolveSymbol method")
//             },
//             ServiceNamesFunc: func() []string {
// 	               panic("mock out the ServiceNames method")
//             },
//         }
//
//         // use mockedSpec in code that requires idl.Spec
//         // and then make assertions.
//
//     }
type SpecMock struct {
	// FormatDescriptorFunc mocks the FormatDescriptor method.
	FormatDescriptorFunc func(v any) (string, error)

	// RPCFunc mocks the RPC method.
	RPCFunc func(svcName string, rpcName string) (*grpc.RPC, error)

	// RPCsFunc mocks the RPCs method.
	RPCsFunc func(svcName string) ([]*grpc.RPC, error)

	// ResolveSymbolFunc mocks the ResolveSymbol method.
	ResolveSymbolFunc func(symbol string) (any, error)

	// ServiceNamesFunc mocks the ServiceNames method.
	ServiceNamesFunc func() []string

	// calls tracks calls to the methods.
	calls struct {
		// FormatDescriptor holds details about calls to the FormatDescriptor method.
		FormatDescriptor []struct {
			// V is the v argument value.
			V any
		}
		// RPC holds details about calls to the RPC method.
		RPC []struct {
			// SvcName is the svcName argument value.
			SvcName string
			// RpcName is the rpcName argument value.
			RpcName string
		}
		// RPCs holds details about calls to the RPCs method.
		RPCs []struct {
			// SvcName is the svcName argument value.
			SvcName string
		}
		// ResolveSymbol holds details about calls to the ResolveSymbol method.
		ResolveSymbol []struct {
			// Symbol is the symbol argument value.
			Symbol string
		}
		// ServiceNames holds details about calls to the ServiceNames method.
		ServiceNames []struct {
		}
	}
}

// FormatDescriptor calls FormatDescriptorFunc.
func (mock *SpecMock) FormatDescriptor(v any) (string, error) {
	if mock.FormatDescriptorFunc == nil {
		panic("SpecMock.FormatDescriptorFunc: method is nil but Spec.FormatDescriptor was just called")
	}
	callInfo := struct {
		V any
	}{
		V: v,
	}
	lockSpecMockFormatDescriptor.Lock()
	mock.calls.FormatDescriptor = append(mock.calls.FormatDescriptor, callInfo)
	lockSpecMockFormatDescriptor.Unlock()
	return mock.FormatDescriptorFunc(v)
}

// FormatDescriptorCalls gets all the calls that were made to FormatDescriptor.
// Check the length with:
//     len(mockedSpec.FormatDescriptorCalls())
func (mock *SpecMock) FormatDescriptorCalls() []struct {
	V any
} {
	var calls []struct {
		V any
	}
	lockSpecMockFormatDescriptor.RLock()
	calls = mock.calls.FormatDescriptor
	lockSpecMockFormatDescriptor.RUnlock()
	return calls
}

// RPC calls RPCFunc.
func (mock *SpecMock) RPC(svcName string, rpcName string) (*grpc.RPC, error) {
	if mock.RPCFunc == nil {
		panic("SpecMock.RPCFunc: method is nil but Spec.RPC was just called")
	}
	callInfo := struct {
		SvcName string
		RpcName string
	}{
		SvcName: svcName,
		RpcName: rpcName,
	}
	lockSpecMockRPC.Lock()
	mock.calls.RPC = append(mock.calls.RPC, callInfo)
	lockSpecMockRPC.Unlock()
	return mock.RPCFunc(svcName, rpcName)
}

// RPCCalls gets all the calls that were made to RPC.
// Check the length with:
//     len(mockedSpec.RPCCalls())
func (mock *SpecMock) RPCCalls() []struct {
	SvcName string
	RpcName string
} {
	var calls []struct {
		SvcName string
		RpcName string
	}
	lockSpecMockRPC.RLock()
	calls = mock.calls.RPC
	lockSpecMockRPC.RUnlock()
	return calls
}

// RPCs calls RPCsFunc.
func (mock *SpecMock) RPCs(svcName string) ([]*grpc.RPC, error) {
	if mock.RPCsFunc == nil {
		panic("SpecMock.RPCsFunc: method is nil but Spec.RPCs was just called")
	}
	callInfo := struct {
		SvcName string
	}{
		SvcName: svcName,
	}
	lockSpecMockRPCs.Lock()
	mock.calls.RPCs = append(mock.calls.RPCs, callInfo)
	lockSpecMockRPCs.Unlock()
	return mock.RPCsFunc(svcName)
}

// RPCsCalls gets all the calls that were made to RPCs.
// Check the length with:
//     len(mockedSpec.RPCsCalls())
func (mock *SpecMock) RPCsCalls() []struct {
	SvcName string
} {
	var calls []struct {
		SvcName string
	}
	lockSpecMockRPCs.RLock()
	calls = mock.calls.RPCs
	lockSpecMockRPCs.RUnlock()
	return calls
}

// ResolveSymbol calls ResolveSymbolFunc.
func (mock *SpecMock) ResolveSymbol(symbol string) (any, error) {
	if mock.ResolveSymbolFunc == nil {
		panic("SpecMock.ResolveSymbolFunc: method is nil but Spec.ResolveSymbol was just called")
	}
	callInfo := struct {
		Symbol string
	}{
		Symbol: symbol,
	}
	lockSpecMockResolveSymbol.Lock()
	mock.calls.ResolveSymbol = append(mock.calls.ResolveSymbol, callInfo)
	lockSpecMockResolveSymbol.Unlock()
	return mock.ResolveSymbolFunc(symbol)
}

// ResolveSymbolCalls gets all the calls that were made to ResolveSymbol.
// Check the length with:
//     len(mockedSpec.ResolveSymbolCalls())
func (mock *SpecMock) ResolveSymbolCalls() []struct {
	Symbol string
} {
	var calls []struct {
		Symbol string
	}
	lockSpecMockResolveSymbol.RLock()
	calls = mock.calls.ResolveSymbol
	lockSpecMockResolveSymbol.RUnlock()
	return calls
}

// ServiceNames calls ServiceNamesFunc.
func (mock *SpecMock) ServiceNames() []string {
	if mock.ServiceNamesFunc == nil {
		panic("SpecMock.ServiceNamesFunc: method is nil but Spec.ServiceNames was just called")
	}
	callInfo := struct {
	}{}
	lockSpecMockServiceNames.Lock()
	mock.calls.ServiceNames = append(mock.calls.ServiceNames, callInfo)
	lockSpecMockServiceNames.Unlock()
	return mock.ServiceNamesFunc()
}

// ServiceNamesCalls gets all the calls that were made to ServiceNames.
// Check the length with:
//     len(mockedSpec.ServiceNamesCalls())
func (mock *SpecMock) ServiceNamesCalls() []struct {
} {
	var calls []struct {
	}
	lockSpecMockServiceNames.RLock()
	calls = mock.calls.ServiceNames
	lockSpecMockServiceNames.RUnlock()
	return calls
}
