// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mockentity

import (
	"context"
	"github.com/golang/protobuf/proto"
	"github.com/jhump/protoreflect/desc"
	"github.com/ktr0731/evans/entity"
	"google.golang.org/grpc"
	"sync"
)

var (
	lockFieldMockFQRN       sync.RWMutex
	lockFieldMockFieldName  sync.RWMutex
	lockFieldMockIsRepeated sync.RWMutex
	lockFieldMockPBType     sync.RWMutex
	lockFieldMockType       sync.RWMutex
)

// Ensure, that FieldMock does implement Field.
// If this is not the case, regenerate this file with moq.
var _ entity.Field = &FieldMock{}

// FieldMock is a mock implementation of Field.
//
//     func TestSomethingThatUsesField(t *testing.T) {
//
//         // make and configure a mocked Field
//         mockedField := &FieldMock{
//             FQRNFunc: func() string {
// 	               panic("mock out the FQRN method")
//             },
//             FieldNameFunc: func() string {
// 	               panic("mock out the FieldName method")
//             },
//             IsRepeatedFunc: func() bool {
// 	               panic("mock out the IsRepeated method")
//             },
//             PBTypeFunc: func() string {
// 	               panic("mock out the PBType method")
//             },
//             TypeFunc: func() entity.FieldType {
// 	               panic("mock out the Type method")
//             },
//         }
//
//         // use mockedField in code that requires Field
//         // and then make assertions.
//
//     }
type FieldMock struct {
	// FQRNFunc mocks the FQRN method.
	FQRNFunc func() string

	// FieldNameFunc mocks the FieldName method.
	FieldNameFunc func() string

	// IsRepeatedFunc mocks the IsRepeated method.
	IsRepeatedFunc func() bool

	// PBTypeFunc mocks the PBType method.
	PBTypeFunc func() string

	// TypeFunc mocks the Type method.
	TypeFunc func() entity.FieldType

	// calls tracks calls to the methods.
	calls struct {
		// FQRN holds details about calls to the FQRN method.
		FQRN []struct {
		}
		// FieldName holds details about calls to the FieldName method.
		FieldName []struct {
		}
		// IsRepeated holds details about calls to the IsRepeated method.
		IsRepeated []struct {
		}
		// PBType holds details about calls to the PBType method.
		PBType []struct {
		}
		// Type holds details about calls to the Type method.
		Type []struct {
		}
	}
}

// FQRN calls FQRNFunc.
func (mock *FieldMock) FQRN() string {
	if mock.FQRNFunc == nil {
		panic("FieldMock.FQRNFunc: method is nil but Field.FQRN was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockFQRN.Lock()
	mock.calls.FQRN = append(mock.calls.FQRN, callInfo)
	lockFieldMockFQRN.Unlock()
	return mock.FQRNFunc()
}

// FQRNCalls gets all the calls that were made to FQRN.
// Check the length with:
//     len(mockedField.FQRNCalls())
func (mock *FieldMock) FQRNCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockFQRN.RLock()
	calls = mock.calls.FQRN
	lockFieldMockFQRN.RUnlock()
	return calls
}

// FieldName calls FieldNameFunc.
func (mock *FieldMock) FieldName() string {
	if mock.FieldNameFunc == nil {
		panic("FieldMock.FieldNameFunc: method is nil but Field.FieldName was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockFieldName.Lock()
	mock.calls.FieldName = append(mock.calls.FieldName, callInfo)
	lockFieldMockFieldName.Unlock()
	return mock.FieldNameFunc()
}

// FieldNameCalls gets all the calls that were made to FieldName.
// Check the length with:
//     len(mockedField.FieldNameCalls())
func (mock *FieldMock) FieldNameCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockFieldName.RLock()
	calls = mock.calls.FieldName
	lockFieldMockFieldName.RUnlock()
	return calls
}

// IsRepeated calls IsRepeatedFunc.
func (mock *FieldMock) IsRepeated() bool {
	if mock.IsRepeatedFunc == nil {
		panic("FieldMock.IsRepeatedFunc: method is nil but Field.IsRepeated was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockIsRepeated.Lock()
	mock.calls.IsRepeated = append(mock.calls.IsRepeated, callInfo)
	lockFieldMockIsRepeated.Unlock()
	return mock.IsRepeatedFunc()
}

// IsRepeatedCalls gets all the calls that were made to IsRepeated.
// Check the length with:
//     len(mockedField.IsRepeatedCalls())
func (mock *FieldMock) IsRepeatedCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockIsRepeated.RLock()
	calls = mock.calls.IsRepeated
	lockFieldMockIsRepeated.RUnlock()
	return calls
}

// PBType calls PBTypeFunc.
func (mock *FieldMock) PBType() string {
	if mock.PBTypeFunc == nil {
		panic("FieldMock.PBTypeFunc: method is nil but Field.PBType was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockPBType.Lock()
	mock.calls.PBType = append(mock.calls.PBType, callInfo)
	lockFieldMockPBType.Unlock()
	return mock.PBTypeFunc()
}

// PBTypeCalls gets all the calls that were made to PBType.
// Check the length with:
//     len(mockedField.PBTypeCalls())
func (mock *FieldMock) PBTypeCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockPBType.RLock()
	calls = mock.calls.PBType
	lockFieldMockPBType.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *FieldMock) Type() entity.FieldType {
	if mock.TypeFunc == nil {
		panic("FieldMock.TypeFunc: method is nil but Field.Type was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	lockFieldMockType.Unlock()
	return mock.TypeFunc()
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//     len(mockedField.TypeCalls())
func (mock *FieldMock) TypeCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockType.RLock()
	calls = mock.calls.Type
	lockFieldMockType.RUnlock()
	return calls
}

var (
	lockMessageMockDesc     sync.RWMutex
	lockMessageMockFields   sync.RWMutex
	lockMessageMockIsCycled sync.RWMutex
	lockMessageMockName     sync.RWMutex
)

// Ensure, that MessageMock does implement Message.
// If this is not the case, regenerate this file with moq.
var _ entity.Message = &MessageMock{}

// MessageMock is a mock implementation of Message.
//
//     func TestSomethingThatUsesMessage(t *testing.T) {
//
//         // make and configure a mocked Message
//         mockedMessage := &MessageMock{
//             DescFunc: func() *desc.MessageDescriptor {
// 	               panic("mock out the Desc method")
//             },
//             FieldsFunc: func() []entity.Field {
// 	               panic("mock out the Fields method")
//             },
//             IsCycledFunc: func() bool {
// 	               panic("mock out the IsCycled method")
//             },
//             NameFunc: func() string {
// 	               panic("mock out the Name method")
//             },
//         }
//
//         // use mockedMessage in code that requires Message
//         // and then make assertions.
//
//     }
type MessageMock struct {
	// DescFunc mocks the Desc method.
	DescFunc func() *desc.MessageDescriptor

	// FieldsFunc mocks the Fields method.
	FieldsFunc func() []entity.Field

	// IsCycledFunc mocks the IsCycled method.
	IsCycledFunc func() bool

	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Desc holds details about calls to the Desc method.
		Desc []struct {
		}
		// Fields holds details about calls to the Fields method.
		Fields []struct {
		}
		// IsCycled holds details about calls to the IsCycled method.
		IsCycled []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
}

// Desc calls DescFunc.
func (mock *MessageMock) Desc() *desc.MessageDescriptor {
	if mock.DescFunc == nil {
		panic("MessageMock.DescFunc: method is nil but Message.Desc was just called")
	}
	callInfo := struct {
	}{}
	lockMessageMockDesc.Lock()
	mock.calls.Desc = append(mock.calls.Desc, callInfo)
	lockMessageMockDesc.Unlock()
	return mock.DescFunc()
}

// DescCalls gets all the calls that were made to Desc.
// Check the length with:
//     len(mockedMessage.DescCalls())
func (mock *MessageMock) DescCalls() []struct {
} {
	var calls []struct {
	}
	lockMessageMockDesc.RLock()
	calls = mock.calls.Desc
	lockMessageMockDesc.RUnlock()
	return calls
}

// Fields calls FieldsFunc.
func (mock *MessageMock) Fields() []entity.Field {
	if mock.FieldsFunc == nil {
		panic("MessageMock.FieldsFunc: method is nil but Message.Fields was just called")
	}
	callInfo := struct {
	}{}
	lockMessageMockFields.Lock()
	mock.calls.Fields = append(mock.calls.Fields, callInfo)
	lockMessageMockFields.Unlock()
	return mock.FieldsFunc()
}

// FieldsCalls gets all the calls that were made to Fields.
// Check the length with:
//     len(mockedMessage.FieldsCalls())
func (mock *MessageMock) FieldsCalls() []struct {
} {
	var calls []struct {
	}
	lockMessageMockFields.RLock()
	calls = mock.calls.Fields
	lockMessageMockFields.RUnlock()
	return calls
}

// IsCycled calls IsCycledFunc.
func (mock *MessageMock) IsCycled() bool {
	if mock.IsCycledFunc == nil {
		panic("MessageMock.IsCycledFunc: method is nil but Message.IsCycled was just called")
	}
	callInfo := struct {
	}{}
	lockMessageMockIsCycled.Lock()
	mock.calls.IsCycled = append(mock.calls.IsCycled, callInfo)
	lockMessageMockIsCycled.Unlock()
	return mock.IsCycledFunc()
}

// IsCycledCalls gets all the calls that were made to IsCycled.
// Check the length with:
//     len(mockedMessage.IsCycledCalls())
func (mock *MessageMock) IsCycledCalls() []struct {
} {
	var calls []struct {
	}
	lockMessageMockIsCycled.RLock()
	calls = mock.calls.IsCycled
	lockMessageMockIsCycled.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *MessageMock) Name() string {
	if mock.NameFunc == nil {
		panic("MessageMock.NameFunc: method is nil but Message.Name was just called")
	}
	callInfo := struct {
	}{}
	lockMessageMockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	lockMessageMockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedMessage.NameCalls())
func (mock *MessageMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	lockMessageMockName.RLock()
	calls = mock.calls.Name
	lockMessageMockName.RUnlock()
	return calls
}

var (
	lockServiceMockFQRN sync.RWMutex
	lockServiceMockName sync.RWMutex
	lockServiceMockRPCs sync.RWMutex
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ entity.Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//     func TestSomethingThatUsesService(t *testing.T) {
//
//         // make and configure a mocked Service
//         mockedService := &ServiceMock{
//             FQRNFunc: func() string {
// 	               panic("mock out the FQRN method")
//             },
//             NameFunc: func() string {
// 	               panic("mock out the Name method")
//             },
//             RPCsFunc: func() []entity.RPC {
// 	               panic("mock out the RPCs method")
//             },
//         }
//
//         // use mockedService in code that requires Service
//         // and then make assertions.
//
//     }
type ServiceMock struct {
	// FQRNFunc mocks the FQRN method.
	FQRNFunc func() string

	// NameFunc mocks the Name method.
	NameFunc func() string

	// RPCsFunc mocks the RPCs method.
	RPCsFunc func() []entity.RPC

	// calls tracks calls to the methods.
	calls struct {
		// FQRN holds details about calls to the FQRN method.
		FQRN []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// RPCs holds details about calls to the RPCs method.
		RPCs []struct {
		}
	}
}

// FQRN calls FQRNFunc.
func (mock *ServiceMock) FQRN() string {
	if mock.FQRNFunc == nil {
		panic("ServiceMock.FQRNFunc: method is nil but Service.FQRN was just called")
	}
	callInfo := struct {
	}{}
	lockServiceMockFQRN.Lock()
	mock.calls.FQRN = append(mock.calls.FQRN, callInfo)
	lockServiceMockFQRN.Unlock()
	return mock.FQRNFunc()
}

// FQRNCalls gets all the calls that were made to FQRN.
// Check the length with:
//     len(mockedService.FQRNCalls())
func (mock *ServiceMock) FQRNCalls() []struct {
} {
	var calls []struct {
	}
	lockServiceMockFQRN.RLock()
	calls = mock.calls.FQRN
	lockServiceMockFQRN.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *ServiceMock) Name() string {
	if mock.NameFunc == nil {
		panic("ServiceMock.NameFunc: method is nil but Service.Name was just called")
	}
	callInfo := struct {
	}{}
	lockServiceMockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	lockServiceMockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedService.NameCalls())
func (mock *ServiceMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	lockServiceMockName.RLock()
	calls = mock.calls.Name
	lockServiceMockName.RUnlock()
	return calls
}

// RPCs calls RPCsFunc.
func (mock *ServiceMock) RPCs() []entity.RPC {
	if mock.RPCsFunc == nil {
		panic("ServiceMock.RPCsFunc: method is nil but Service.RPCs was just called")
	}
	callInfo := struct {
	}{}
	lockServiceMockRPCs.Lock()
	mock.calls.RPCs = append(mock.calls.RPCs, callInfo)
	lockServiceMockRPCs.Unlock()
	return mock.RPCsFunc()
}

// RPCsCalls gets all the calls that were made to RPCs.
// Check the length with:
//     len(mockedService.RPCsCalls())
func (mock *ServiceMock) RPCsCalls() []struct {
} {
	var calls []struct {
	}
	lockServiceMockRPCs.RLock()
	calls = mock.calls.RPCs
	lockServiceMockRPCs.RUnlock()
	return calls
}

var (
	lockRPCMockFQRN              sync.RWMutex
	lockRPCMockIsClientStreaming sync.RWMutex
	lockRPCMockIsServerStreaming sync.RWMutex
	lockRPCMockName              sync.RWMutex
	lockRPCMockRequestMessage    sync.RWMutex
	lockRPCMockResponseMessage   sync.RWMutex
	lockRPCMockStreamDesc        sync.RWMutex
)

// Ensure, that RPCMock does implement RPC.
// If this is not the case, regenerate this file with moq.
var _ entity.RPC = &RPCMock{}

// RPCMock is a mock implementation of RPC.
//
//     func TestSomethingThatUsesRPC(t *testing.T) {
//
//         // make and configure a mocked RPC
//         mockedRPC := &RPCMock{
//             FQRNFunc: func() string {
// 	               panic("mock out the FQRN method")
//             },
//             IsClientStreamingFunc: func() bool {
// 	               panic("mock out the IsClientStreaming method")
//             },
//             IsServerStreamingFunc: func() bool {
// 	               panic("mock out the IsServerStreaming method")
//             },
//             NameFunc: func() string {
// 	               panic("mock out the Name method")
//             },
//             RequestMessageFunc: func() entity.Message {
// 	               panic("mock out the RequestMessage method")
//             },
//             ResponseMessageFunc: func() entity.Message {
// 	               panic("mock out the ResponseMessage method")
//             },
//             StreamDescFunc: func() *grpc.StreamDesc {
// 	               panic("mock out the StreamDesc method")
//             },
//         }
//
//         // use mockedRPC in code that requires RPC
//         // and then make assertions.
//
//     }
type RPCMock struct {
	// FQRNFunc mocks the FQRN method.
	FQRNFunc func() string

	// IsClientStreamingFunc mocks the IsClientStreaming method.
	IsClientStreamingFunc func() bool

	// IsServerStreamingFunc mocks the IsServerStreaming method.
	IsServerStreamingFunc func() bool

	// NameFunc mocks the Name method.
	NameFunc func() string

	// RequestMessageFunc mocks the RequestMessage method.
	RequestMessageFunc func() entity.Message

	// ResponseMessageFunc mocks the ResponseMessage method.
	ResponseMessageFunc func() entity.Message

	// StreamDescFunc mocks the StreamDesc method.
	StreamDescFunc func() *grpc.StreamDesc

	// calls tracks calls to the methods.
	calls struct {
		// FQRN holds details about calls to the FQRN method.
		FQRN []struct {
		}
		// IsClientStreaming holds details about calls to the IsClientStreaming method.
		IsClientStreaming []struct {
		}
		// IsServerStreaming holds details about calls to the IsServerStreaming method.
		IsServerStreaming []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// RequestMessage holds details about calls to the RequestMessage method.
		RequestMessage []struct {
		}
		// ResponseMessage holds details about calls to the ResponseMessage method.
		ResponseMessage []struct {
		}
		// StreamDesc holds details about calls to the StreamDesc method.
		StreamDesc []struct {
		}
	}
}

// FQRN calls FQRNFunc.
func (mock *RPCMock) FQRN() string {
	if mock.FQRNFunc == nil {
		panic("RPCMock.FQRNFunc: method is nil but RPC.FQRN was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockFQRN.Lock()
	mock.calls.FQRN = append(mock.calls.FQRN, callInfo)
	lockRPCMockFQRN.Unlock()
	return mock.FQRNFunc()
}

// FQRNCalls gets all the calls that were made to FQRN.
// Check the length with:
//     len(mockedRPC.FQRNCalls())
func (mock *RPCMock) FQRNCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockFQRN.RLock()
	calls = mock.calls.FQRN
	lockRPCMockFQRN.RUnlock()
	return calls
}

// IsClientStreaming calls IsClientStreamingFunc.
func (mock *RPCMock) IsClientStreaming() bool {
	if mock.IsClientStreamingFunc == nil {
		panic("RPCMock.IsClientStreamingFunc: method is nil but RPC.IsClientStreaming was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockIsClientStreaming.Lock()
	mock.calls.IsClientStreaming = append(mock.calls.IsClientStreaming, callInfo)
	lockRPCMockIsClientStreaming.Unlock()
	return mock.IsClientStreamingFunc()
}

// IsClientStreamingCalls gets all the calls that were made to IsClientStreaming.
// Check the length with:
//     len(mockedRPC.IsClientStreamingCalls())
func (mock *RPCMock) IsClientStreamingCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockIsClientStreaming.RLock()
	calls = mock.calls.IsClientStreaming
	lockRPCMockIsClientStreaming.RUnlock()
	return calls
}

// IsServerStreaming calls IsServerStreamingFunc.
func (mock *RPCMock) IsServerStreaming() bool {
	if mock.IsServerStreamingFunc == nil {
		panic("RPCMock.IsServerStreamingFunc: method is nil but RPC.IsServerStreaming was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockIsServerStreaming.Lock()
	mock.calls.IsServerStreaming = append(mock.calls.IsServerStreaming, callInfo)
	lockRPCMockIsServerStreaming.Unlock()
	return mock.IsServerStreamingFunc()
}

// IsServerStreamingCalls gets all the calls that were made to IsServerStreaming.
// Check the length with:
//     len(mockedRPC.IsServerStreamingCalls())
func (mock *RPCMock) IsServerStreamingCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockIsServerStreaming.RLock()
	calls = mock.calls.IsServerStreaming
	lockRPCMockIsServerStreaming.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *RPCMock) Name() string {
	if mock.NameFunc == nil {
		panic("RPCMock.NameFunc: method is nil but RPC.Name was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	lockRPCMockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedRPC.NameCalls())
func (mock *RPCMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockName.RLock()
	calls = mock.calls.Name
	lockRPCMockName.RUnlock()
	return calls
}

// RequestMessage calls RequestMessageFunc.
func (mock *RPCMock) RequestMessage() entity.Message {
	if mock.RequestMessageFunc == nil {
		panic("RPCMock.RequestMessageFunc: method is nil but RPC.RequestMessage was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockRequestMessage.Lock()
	mock.calls.RequestMessage = append(mock.calls.RequestMessage, callInfo)
	lockRPCMockRequestMessage.Unlock()
	return mock.RequestMessageFunc()
}

// RequestMessageCalls gets all the calls that were made to RequestMessage.
// Check the length with:
//     len(mockedRPC.RequestMessageCalls())
func (mock *RPCMock) RequestMessageCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockRequestMessage.RLock()
	calls = mock.calls.RequestMessage
	lockRPCMockRequestMessage.RUnlock()
	return calls
}

// ResponseMessage calls ResponseMessageFunc.
func (mock *RPCMock) ResponseMessage() entity.Message {
	if mock.ResponseMessageFunc == nil {
		panic("RPCMock.ResponseMessageFunc: method is nil but RPC.ResponseMessage was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockResponseMessage.Lock()
	mock.calls.ResponseMessage = append(mock.calls.ResponseMessage, callInfo)
	lockRPCMockResponseMessage.Unlock()
	return mock.ResponseMessageFunc()
}

// ResponseMessageCalls gets all the calls that were made to ResponseMessage.
// Check the length with:
//     len(mockedRPC.ResponseMessageCalls())
func (mock *RPCMock) ResponseMessageCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockResponseMessage.RLock()
	calls = mock.calls.ResponseMessage
	lockRPCMockResponseMessage.RUnlock()
	return calls
}

// StreamDesc calls StreamDescFunc.
func (mock *RPCMock) StreamDesc() *grpc.StreamDesc {
	if mock.StreamDescFunc == nil {
		panic("RPCMock.StreamDescFunc: method is nil but RPC.StreamDesc was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockStreamDesc.Lock()
	mock.calls.StreamDesc = append(mock.calls.StreamDesc, callInfo)
	lockRPCMockStreamDesc.Unlock()
	return mock.StreamDescFunc()
}

// StreamDescCalls gets all the calls that were made to StreamDesc.
// Check the length with:
//     len(mockedRPC.StreamDescCalls())
func (mock *RPCMock) StreamDescCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockStreamDesc.RLock()
	calls = mock.calls.StreamDesc
	lockRPCMockStreamDesc.RUnlock()
	return calls
}

var (
	lockClientStreamMockCloseAndReceive sync.RWMutex
	lockClientStreamMockSend            sync.RWMutex
)

// Ensure, that ClientStreamMock does implement ClientStream.
// If this is not the case, regenerate this file with moq.
var _ entity.ClientStream = &ClientStreamMock{}

// ClientStreamMock is a mock implementation of ClientStream.
//
//     func TestSomethingThatUsesClientStream(t *testing.T) {
//
//         // make and configure a mocked ClientStream
//         mockedClientStream := &ClientStreamMock{
//             CloseAndReceiveFunc: func(res *proto.Message) error {
// 	               panic("mock out the CloseAndReceive method")
//             },
//             SendFunc: func(req proto.Message) error {
// 	               panic("mock out the Send method")
//             },
//         }
//
//         // use mockedClientStream in code that requires ClientStream
//         // and then make assertions.
//
//     }
type ClientStreamMock struct {
	// CloseAndReceiveFunc mocks the CloseAndReceive method.
	CloseAndReceiveFunc func(res *proto.Message) error

	// SendFunc mocks the Send method.
	SendFunc func(req proto.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// CloseAndReceive holds details about calls to the CloseAndReceive method.
		CloseAndReceive []struct {
			// Res is the res argument value.
			Res *proto.Message
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// Req is the req argument value.
			Req proto.Message
		}
	}
}

// CloseAndReceive calls CloseAndReceiveFunc.
func (mock *ClientStreamMock) CloseAndReceive(res *proto.Message) error {
	if mock.CloseAndReceiveFunc == nil {
		panic("ClientStreamMock.CloseAndReceiveFunc: method is nil but ClientStream.CloseAndReceive was just called")
	}
	callInfo := struct {
		Res *proto.Message
	}{
		Res: res,
	}
	lockClientStreamMockCloseAndReceive.Lock()
	mock.calls.CloseAndReceive = append(mock.calls.CloseAndReceive, callInfo)
	lockClientStreamMockCloseAndReceive.Unlock()
	return mock.CloseAndReceiveFunc(res)
}

// CloseAndReceiveCalls gets all the calls that were made to CloseAndReceive.
// Check the length with:
//     len(mockedClientStream.CloseAndReceiveCalls())
func (mock *ClientStreamMock) CloseAndReceiveCalls() []struct {
	Res *proto.Message
} {
	var calls []struct {
		Res *proto.Message
	}
	lockClientStreamMockCloseAndReceive.RLock()
	calls = mock.calls.CloseAndReceive
	lockClientStreamMockCloseAndReceive.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *ClientStreamMock) Send(req proto.Message) error {
	if mock.SendFunc == nil {
		panic("ClientStreamMock.SendFunc: method is nil but ClientStream.Send was just called")
	}
	callInfo := struct {
		Req proto.Message
	}{
		Req: req,
	}
	lockClientStreamMockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	lockClientStreamMockSend.Unlock()
	return mock.SendFunc(req)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedClientStream.SendCalls())
func (mock *ClientStreamMock) SendCalls() []struct {
	Req proto.Message
} {
	var calls []struct {
		Req proto.Message
	}
	lockClientStreamMockSend.RLock()
	calls = mock.calls.Send
	lockClientStreamMockSend.RUnlock()
	return calls
}

var (
	lockServerStreamMockReceive sync.RWMutex
	lockServerStreamMockSend    sync.RWMutex
)

// Ensure, that ServerStreamMock does implement ServerStream.
// If this is not the case, regenerate this file with moq.
var _ entity.ServerStream = &ServerStreamMock{}

// ServerStreamMock is a mock implementation of ServerStream.
//
//     func TestSomethingThatUsesServerStream(t *testing.T) {
//
//         // make and configure a mocked ServerStream
//         mockedServerStream := &ServerStreamMock{
//             ReceiveFunc: func(res *proto.Message) error {
// 	               panic("mock out the Receive method")
//             },
//             SendFunc: func(req proto.Message) error {
// 	               panic("mock out the Send method")
//             },
//         }
//
//         // use mockedServerStream in code that requires ServerStream
//         // and then make assertions.
//
//     }
type ServerStreamMock struct {
	// ReceiveFunc mocks the Receive method.
	ReceiveFunc func(res *proto.Message) error

	// SendFunc mocks the Send method.
	SendFunc func(req proto.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// Receive holds details about calls to the Receive method.
		Receive []struct {
			// Res is the res argument value.
			Res *proto.Message
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// Req is the req argument value.
			Req proto.Message
		}
	}
}

// Receive calls ReceiveFunc.
func (mock *ServerStreamMock) Receive(res *proto.Message) error {
	if mock.ReceiveFunc == nil {
		panic("ServerStreamMock.ReceiveFunc: method is nil but ServerStream.Receive was just called")
	}
	callInfo := struct {
		Res *proto.Message
	}{
		Res: res,
	}
	lockServerStreamMockReceive.Lock()
	mock.calls.Receive = append(mock.calls.Receive, callInfo)
	lockServerStreamMockReceive.Unlock()
	return mock.ReceiveFunc(res)
}

// ReceiveCalls gets all the calls that were made to Receive.
// Check the length with:
//     len(mockedServerStream.ReceiveCalls())
func (mock *ServerStreamMock) ReceiveCalls() []struct {
	Res *proto.Message
} {
	var calls []struct {
		Res *proto.Message
	}
	lockServerStreamMockReceive.RLock()
	calls = mock.calls.Receive
	lockServerStreamMockReceive.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *ServerStreamMock) Send(req proto.Message) error {
	if mock.SendFunc == nil {
		panic("ServerStreamMock.SendFunc: method is nil but ServerStream.Send was just called")
	}
	callInfo := struct {
		Req proto.Message
	}{
		Req: req,
	}
	lockServerStreamMockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	lockServerStreamMockSend.Unlock()
	return mock.SendFunc(req)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedServerStream.SendCalls())
func (mock *ServerStreamMock) SendCalls() []struct {
	Req proto.Message
} {
	var calls []struct {
		Req proto.Message
	}
	lockServerStreamMockSend.RLock()
	calls = mock.calls.Send
	lockServerStreamMockSend.RUnlock()
	return calls
}

var (
	lockBidiStreamMockCloseSend sync.RWMutex
	lockBidiStreamMockReceive   sync.RWMutex
	lockBidiStreamMockSend      sync.RWMutex
)

// Ensure, that BidiStreamMock does implement BidiStream.
// If this is not the case, regenerate this file with moq.
var _ entity.BidiStream = &BidiStreamMock{}

// BidiStreamMock is a mock implementation of BidiStream.
//
//     func TestSomethingThatUsesBidiStream(t *testing.T) {
//
//         // make and configure a mocked BidiStream
//         mockedBidiStream := &BidiStreamMock{
//             CloseSendFunc: func() error {
// 	               panic("mock out the CloseSend method")
//             },
//             ReceiveFunc: func(res *proto.Message) error {
// 	               panic("mock out the Receive method")
//             },
//             SendFunc: func(req proto.Message) error {
// 	               panic("mock out the Send method")
//             },
//         }
//
//         // use mockedBidiStream in code that requires BidiStream
//         // and then make assertions.
//
//     }
type BidiStreamMock struct {
	// CloseSendFunc mocks the CloseSend method.
	CloseSendFunc func() error

	// ReceiveFunc mocks the Receive method.
	ReceiveFunc func(res *proto.Message) error

	// SendFunc mocks the Send method.
	SendFunc func(req proto.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// CloseSend holds details about calls to the CloseSend method.
		CloseSend []struct {
		}
		// Receive holds details about calls to the Receive method.
		Receive []struct {
			// Res is the res argument value.
			Res *proto.Message
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// Req is the req argument value.
			Req proto.Message
		}
	}
}

// CloseSend calls CloseSendFunc.
func (mock *BidiStreamMock) CloseSend() error {
	if mock.CloseSendFunc == nil {
		panic("BidiStreamMock.CloseSendFunc: method is nil but BidiStream.CloseSend was just called")
	}
	callInfo := struct {
	}{}
	lockBidiStreamMockCloseSend.Lock()
	mock.calls.CloseSend = append(mock.calls.CloseSend, callInfo)
	lockBidiStreamMockCloseSend.Unlock()
	return mock.CloseSendFunc()
}

// CloseSendCalls gets all the calls that were made to CloseSend.
// Check the length with:
//     len(mockedBidiStream.CloseSendCalls())
func (mock *BidiStreamMock) CloseSendCalls() []struct {
} {
	var calls []struct {
	}
	lockBidiStreamMockCloseSend.RLock()
	calls = mock.calls.CloseSend
	lockBidiStreamMockCloseSend.RUnlock()
	return calls
}

// Receive calls ReceiveFunc.
func (mock *BidiStreamMock) Receive(res *proto.Message) error {
	if mock.ReceiveFunc == nil {
		panic("BidiStreamMock.ReceiveFunc: method is nil but BidiStream.Receive was just called")
	}
	callInfo := struct {
		Res *proto.Message
	}{
		Res: res,
	}
	lockBidiStreamMockReceive.Lock()
	mock.calls.Receive = append(mock.calls.Receive, callInfo)
	lockBidiStreamMockReceive.Unlock()
	return mock.ReceiveFunc(res)
}

// ReceiveCalls gets all the calls that were made to Receive.
// Check the length with:
//     len(mockedBidiStream.ReceiveCalls())
func (mock *BidiStreamMock) ReceiveCalls() []struct {
	Res *proto.Message
} {
	var calls []struct {
		Res *proto.Message
	}
	lockBidiStreamMockReceive.RLock()
	calls = mock.calls.Receive
	lockBidiStreamMockReceive.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *BidiStreamMock) Send(req proto.Message) error {
	if mock.SendFunc == nil {
		panic("BidiStreamMock.SendFunc: method is nil but BidiStream.Send was just called")
	}
	callInfo := struct {
		Req proto.Message
	}{
		Req: req,
	}
	lockBidiStreamMockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	lockBidiStreamMockSend.Unlock()
	return mock.SendFunc(req)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedBidiStream.SendCalls())
func (mock *BidiStreamMock) SendCalls() []struct {
	Req proto.Message
} {
	var calls []struct {
		Req proto.Message
	}
	lockBidiStreamMockSend.RLock()
	calls = mock.calls.Send
	lockBidiStreamMockSend.RUnlock()
	return calls
}

var (
	lockGRPCClientMockClose             sync.RWMutex
	lockGRPCClientMockInvoke            sync.RWMutex
	lockGRPCClientMockListPackages      sync.RWMutex
	lockGRPCClientMockNewBidiStream     sync.RWMutex
	lockGRPCClientMockNewClientStream   sync.RWMutex
	lockGRPCClientMockNewServerStream   sync.RWMutex
	lockGRPCClientMockReflectionEnabled sync.RWMutex
)

// Ensure, that GRPCClientMock does implement GRPCClient.
// If this is not the case, regenerate this file with moq.
var _ entity.GRPCClient = &GRPCClientMock{}

// GRPCClientMock is a mock implementation of GRPCClient.
//
//     func TestSomethingThatUsesGRPCClient(t *testing.T) {
//
//         // make and configure a mocked GRPCClient
//         mockedGRPCClient := &GRPCClientMock{
//             CloseFunc: func(ctx context.Context) error {
// 	               panic("mock out the Close method")
//             },
//             InvokeFunc: func(ctx context.Context, fqrn string, req interface{}, res interface{}) error {
// 	               panic("mock out the Invoke method")
//             },
//             ListPackagesFunc: func() ([]*entity.Package, error) {
// 	               panic("mock out the ListPackages method")
//             },
//             NewBidiStreamFunc: func(ctx context.Context, rpc entity.RPC) (entity.BidiStream, error) {
// 	               panic("mock out the NewBidiStream method")
//             },
//             NewClientStreamFunc: func(ctx context.Context, rpc entity.RPC) (entity.ClientStream, error) {
// 	               panic("mock out the NewClientStream method")
//             },
//             NewServerStreamFunc: func(ctx context.Context, rpc entity.RPC) (entity.ServerStream, error) {
// 	               panic("mock out the NewServerStream method")
//             },
//             ReflectionEnabledFunc: func() bool {
// 	               panic("mock out the ReflectionEnabled method")
//             },
//         }
//
//         // use mockedGRPCClient in code that requires GRPCClient
//         // and then make assertions.
//
//     }
type GRPCClientMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// InvokeFunc mocks the Invoke method.
	InvokeFunc func(ctx context.Context, fqrn string, req interface{}, res interface{}) error

	// ListPackagesFunc mocks the ListPackages method.
	ListPackagesFunc func() ([]*entity.Package, error)

	// NewBidiStreamFunc mocks the NewBidiStream method.
	NewBidiStreamFunc func(ctx context.Context, rpc entity.RPC) (entity.BidiStream, error)

	// NewClientStreamFunc mocks the NewClientStream method.
	NewClientStreamFunc func(ctx context.Context, rpc entity.RPC) (entity.ClientStream, error)

	// NewServerStreamFunc mocks the NewServerStream method.
	NewServerStreamFunc func(ctx context.Context, rpc entity.RPC) (entity.ServerStream, error)

	// ReflectionEnabledFunc mocks the ReflectionEnabled method.
	ReflectionEnabledFunc func() bool

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Invoke holds details about calls to the Invoke method.
		Invoke []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fqrn is the fqrn argument value.
			Fqrn string
			// Req is the req argument value.
			Req interface{}
			// Res is the res argument value.
			Res interface{}
		}
		// ListPackages holds details about calls to the ListPackages method.
		ListPackages []struct {
		}
		// NewBidiStream holds details about calls to the NewBidiStream method.
		NewBidiStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RPC is the rpc argument value.
			RPC entity.RPC
		}
		// NewClientStream holds details about calls to the NewClientStream method.
		NewClientStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RPC is the rpc argument value.
			RPC entity.RPC
		}
		// NewServerStream holds details about calls to the NewServerStream method.
		NewServerStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RPC is the rpc argument value.
			RPC entity.RPC
		}
		// ReflectionEnabled holds details about calls to the ReflectionEnabled method.
		ReflectionEnabled []struct {
		}
	}
}

// Close calls CloseFunc.
func (mock *GRPCClientMock) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("GRPCClientMock.CloseFunc: method is nil but GRPCClient.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	lockGRPCClientMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockGRPCClientMockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedGRPCClient.CloseCalls())
func (mock *GRPCClientMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	lockGRPCClientMockClose.RLock()
	calls = mock.calls.Close
	lockGRPCClientMockClose.RUnlock()
	return calls
}

// Invoke calls InvokeFunc.
func (mock *GRPCClientMock) Invoke(ctx context.Context, fqrn string, req interface{}, res interface{}) error {
	if mock.InvokeFunc == nil {
		panic("GRPCClientMock.InvokeFunc: method is nil but GRPCClient.Invoke was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Fqrn string
		Req  interface{}
		Res  interface{}
	}{
		Ctx:  ctx,
		Fqrn: fqrn,
		Req:  req,
		Res:  res,
	}
	lockGRPCClientMockInvoke.Lock()
	mock.calls.Invoke = append(mock.calls.Invoke, callInfo)
	lockGRPCClientMockInvoke.Unlock()
	return mock.InvokeFunc(ctx, fqrn, req, res)
}

// InvokeCalls gets all the calls that were made to Invoke.
// Check the length with:
//     len(mockedGRPCClient.InvokeCalls())
func (mock *GRPCClientMock) InvokeCalls() []struct {
	Ctx  context.Context
	Fqrn string
	Req  interface{}
	Res  interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Fqrn string
		Req  interface{}
		Res  interface{}
	}
	lockGRPCClientMockInvoke.RLock()
	calls = mock.calls.Invoke
	lockGRPCClientMockInvoke.RUnlock()
	return calls
}

// ListPackages calls ListPackagesFunc.
func (mock *GRPCClientMock) ListPackages() ([]*entity.Package, error) {
	if mock.ListPackagesFunc == nil {
		panic("GRPCClientMock.ListPackagesFunc: method is nil but GRPCClient.ListPackages was just called")
	}
	callInfo := struct {
	}{}
	lockGRPCClientMockListPackages.Lock()
	mock.calls.ListPackages = append(mock.calls.ListPackages, callInfo)
	lockGRPCClientMockListPackages.Unlock()
	return mock.ListPackagesFunc()
}

// ListPackagesCalls gets all the calls that were made to ListPackages.
// Check the length with:
//     len(mockedGRPCClient.ListPackagesCalls())
func (mock *GRPCClientMock) ListPackagesCalls() []struct {
} {
	var calls []struct {
	}
	lockGRPCClientMockListPackages.RLock()
	calls = mock.calls.ListPackages
	lockGRPCClientMockListPackages.RUnlock()
	return calls
}

// NewBidiStream calls NewBidiStreamFunc.
func (mock *GRPCClientMock) NewBidiStream(ctx context.Context, rpc entity.RPC) (entity.BidiStream, error) {
	if mock.NewBidiStreamFunc == nil {
		panic("GRPCClientMock.NewBidiStreamFunc: method is nil but GRPCClient.NewBidiStream was just called")
	}
	callInfo := struct {
		Ctx context.Context
		RPC entity.RPC
	}{
		Ctx: ctx,
		RPC: rpc,
	}
	lockGRPCClientMockNewBidiStream.Lock()
	mock.calls.NewBidiStream = append(mock.calls.NewBidiStream, callInfo)
	lockGRPCClientMockNewBidiStream.Unlock()
	return mock.NewBidiStreamFunc(ctx, rpc)
}

// NewBidiStreamCalls gets all the calls that were made to NewBidiStream.
// Check the length with:
//     len(mockedGRPCClient.NewBidiStreamCalls())
func (mock *GRPCClientMock) NewBidiStreamCalls() []struct {
	Ctx context.Context
	RPC entity.RPC
} {
	var calls []struct {
		Ctx context.Context
		RPC entity.RPC
	}
	lockGRPCClientMockNewBidiStream.RLock()
	calls = mock.calls.NewBidiStream
	lockGRPCClientMockNewBidiStream.RUnlock()
	return calls
}

// NewClientStream calls NewClientStreamFunc.
func (mock *GRPCClientMock) NewClientStream(ctx context.Context, rpc entity.RPC) (entity.ClientStream, error) {
	if mock.NewClientStreamFunc == nil {
		panic("GRPCClientMock.NewClientStreamFunc: method is nil but GRPCClient.NewClientStream was just called")
	}
	callInfo := struct {
		Ctx context.Context
		RPC entity.RPC
	}{
		Ctx: ctx,
		RPC: rpc,
	}
	lockGRPCClientMockNewClientStream.Lock()
	mock.calls.NewClientStream = append(mock.calls.NewClientStream, callInfo)
	lockGRPCClientMockNewClientStream.Unlock()
	return mock.NewClientStreamFunc(ctx, rpc)
}

// NewClientStreamCalls gets all the calls that were made to NewClientStream.
// Check the length with:
//     len(mockedGRPCClient.NewClientStreamCalls())
func (mock *GRPCClientMock) NewClientStreamCalls() []struct {
	Ctx context.Context
	RPC entity.RPC
} {
	var calls []struct {
		Ctx context.Context
		RPC entity.RPC
	}
	lockGRPCClientMockNewClientStream.RLock()
	calls = mock.calls.NewClientStream
	lockGRPCClientMockNewClientStream.RUnlock()
	return calls
}

// NewServerStream calls NewServerStreamFunc.
func (mock *GRPCClientMock) NewServerStream(ctx context.Context, rpc entity.RPC) (entity.ServerStream, error) {
	if mock.NewServerStreamFunc == nil {
		panic("GRPCClientMock.NewServerStreamFunc: method is nil but GRPCClient.NewServerStream was just called")
	}
	callInfo := struct {
		Ctx context.Context
		RPC entity.RPC
	}{
		Ctx: ctx,
		RPC: rpc,
	}
	lockGRPCClientMockNewServerStream.Lock()
	mock.calls.NewServerStream = append(mock.calls.NewServerStream, callInfo)
	lockGRPCClientMockNewServerStream.Unlock()
	return mock.NewServerStreamFunc(ctx, rpc)
}

// NewServerStreamCalls gets all the calls that were made to NewServerStream.
// Check the length with:
//     len(mockedGRPCClient.NewServerStreamCalls())
func (mock *GRPCClientMock) NewServerStreamCalls() []struct {
	Ctx context.Context
	RPC entity.RPC
} {
	var calls []struct {
		Ctx context.Context
		RPC entity.RPC
	}
	lockGRPCClientMockNewServerStream.RLock()
	calls = mock.calls.NewServerStream
	lockGRPCClientMockNewServerStream.RUnlock()
	return calls
}

// ReflectionEnabled calls ReflectionEnabledFunc.
func (mock *GRPCClientMock) ReflectionEnabled() bool {
	if mock.ReflectionEnabledFunc == nil {
		panic("GRPCClientMock.ReflectionEnabledFunc: method is nil but GRPCClient.ReflectionEnabled was just called")
	}
	callInfo := struct {
	}{}
	lockGRPCClientMockReflectionEnabled.Lock()
	mock.calls.ReflectionEnabled = append(mock.calls.ReflectionEnabled, callInfo)
	lockGRPCClientMockReflectionEnabled.Unlock()
	return mock.ReflectionEnabledFunc()
}

// ReflectionEnabledCalls gets all the calls that were made to ReflectionEnabled.
// Check the length with:
//     len(mockedGRPCClient.ReflectionEnabledCalls())
func (mock *GRPCClientMock) ReflectionEnabledCalls() []struct {
} {
	var calls []struct {
	}
	lockGRPCClientMockReflectionEnabled.RLock()
	calls = mock.calls.ReflectionEnabled
	lockGRPCClientMockReflectionEnabled.RUnlock()
	return calls
}
