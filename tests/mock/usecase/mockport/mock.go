// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mockport

import (
	"github.com/golang/protobuf/proto"
	"github.com/ktr0731/evans/usecase/port"
	"io"
	"sync"
)

var (
	lockOutputPortMockCall     sync.RWMutex
	lockOutputPortMockDescribe sync.RWMutex
	lockOutputPortMockHeader   sync.RWMutex
	lockOutputPortMockPackage  sync.RWMutex
	lockOutputPortMockService  sync.RWMutex
	lockOutputPortMockShow     sync.RWMutex
)

// Ensure, that OutputPortMock does implement OutputPort.
// If this is not the case, regenerate this file with moq.
var _ port.OutputPort = &OutputPortMock{}

// OutputPortMock is a mock implementation of OutputPort.
//
//     func TestSomethingThatUsesOutputPort(t *testing.T) {
//
//         // make and configure a mocked OutputPort
//         mockedOutputPort := &OutputPortMock{
//             CallFunc: func(res proto.Message) (io.Reader, error) {
// 	               panic("mock out the Call method")
//             },
//             DescribeFunc: func(showable port.Showable) (io.Reader, error) {
// 	               panic("mock out the Describe method")
//             },
//             HeaderFunc: func() (io.Reader, error) {
// 	               panic("mock out the Header method")
//             },
//             PackageFunc: func() (io.Reader, error) {
// 	               panic("mock out the Package method")
//             },
//             ServiceFunc: func() (io.Reader, error) {
// 	               panic("mock out the Service method")
//             },
//             ShowFunc: func(showable port.Showable) (io.Reader, error) {
// 	               panic("mock out the Show method")
//             },
//         }
//
//         // use mockedOutputPort in code that requires OutputPort
//         // and then make assertions.
//
//     }
type OutputPortMock struct {
	// CallFunc mocks the Call method.
	CallFunc func(res proto.Message) (io.Reader, error)

	// DescribeFunc mocks the Describe method.
	DescribeFunc func(showable port.Showable) (io.Reader, error)

	// HeaderFunc mocks the Header method.
	HeaderFunc func() (io.Reader, error)

	// PackageFunc mocks the Package method.
	PackageFunc func() (io.Reader, error)

	// ServiceFunc mocks the Service method.
	ServiceFunc func() (io.Reader, error)

	// ShowFunc mocks the Show method.
	ShowFunc func(showable port.Showable) (io.Reader, error)

	// calls tracks calls to the methods.
	calls struct {
		// Call holds details about calls to the Call method.
		Call []struct {
			// Res is the res argument value.
			Res proto.Message
		}
		// Describe holds details about calls to the Describe method.
		Describe []struct {
			// Showable is the showable argument value.
			Showable port.Showable
		}
		// Header holds details about calls to the Header method.
		Header []struct {
		}
		// Package holds details about calls to the Package method.
		Package []struct {
		}
		// Service holds details about calls to the Service method.
		Service []struct {
		}
		// Show holds details about calls to the Show method.
		Show []struct {
			// Showable is the showable argument value.
			Showable port.Showable
		}
	}
}

// Call calls CallFunc.
func (mock *OutputPortMock) Call(res proto.Message) (io.Reader, error) {
	if mock.CallFunc == nil {
		panic("OutputPortMock.CallFunc: method is nil but OutputPort.Call was just called")
	}
	callInfo := struct {
		Res proto.Message
	}{
		Res: res,
	}
	lockOutputPortMockCall.Lock()
	mock.calls.Call = append(mock.calls.Call, callInfo)
	lockOutputPortMockCall.Unlock()
	return mock.CallFunc(res)
}

// CallCalls gets all the calls that were made to Call.
// Check the length with:
//     len(mockedOutputPort.CallCalls())
func (mock *OutputPortMock) CallCalls() []struct {
	Res proto.Message
} {
	var calls []struct {
		Res proto.Message
	}
	lockOutputPortMockCall.RLock()
	calls = mock.calls.Call
	lockOutputPortMockCall.RUnlock()
	return calls
}

// Describe calls DescribeFunc.
func (mock *OutputPortMock) Describe(showable port.Showable) (io.Reader, error) {
	if mock.DescribeFunc == nil {
		panic("OutputPortMock.DescribeFunc: method is nil but OutputPort.Describe was just called")
	}
	callInfo := struct {
		Showable port.Showable
	}{
		Showable: showable,
	}
	lockOutputPortMockDescribe.Lock()
	mock.calls.Describe = append(mock.calls.Describe, callInfo)
	lockOutputPortMockDescribe.Unlock()
	return mock.DescribeFunc(showable)
}

// DescribeCalls gets all the calls that were made to Describe.
// Check the length with:
//     len(mockedOutputPort.DescribeCalls())
func (mock *OutputPortMock) DescribeCalls() []struct {
	Showable port.Showable
} {
	var calls []struct {
		Showable port.Showable
	}
	lockOutputPortMockDescribe.RLock()
	calls = mock.calls.Describe
	lockOutputPortMockDescribe.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *OutputPortMock) Header() (io.Reader, error) {
	if mock.HeaderFunc == nil {
		panic("OutputPortMock.HeaderFunc: method is nil but OutputPort.Header was just called")
	}
	callInfo := struct {
	}{}
	lockOutputPortMockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	lockOutputPortMockHeader.Unlock()
	return mock.HeaderFunc()
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//     len(mockedOutputPort.HeaderCalls())
func (mock *OutputPortMock) HeaderCalls() []struct {
} {
	var calls []struct {
	}
	lockOutputPortMockHeader.RLock()
	calls = mock.calls.Header
	lockOutputPortMockHeader.RUnlock()
	return calls
}

// Package calls PackageFunc.
func (mock *OutputPortMock) Package() (io.Reader, error) {
	if mock.PackageFunc == nil {
		panic("OutputPortMock.PackageFunc: method is nil but OutputPort.Package was just called")
	}
	callInfo := struct {
	}{}
	lockOutputPortMockPackage.Lock()
	mock.calls.Package = append(mock.calls.Package, callInfo)
	lockOutputPortMockPackage.Unlock()
	return mock.PackageFunc()
}

// PackageCalls gets all the calls that were made to Package.
// Check the length with:
//     len(mockedOutputPort.PackageCalls())
func (mock *OutputPortMock) PackageCalls() []struct {
} {
	var calls []struct {
	}
	lockOutputPortMockPackage.RLock()
	calls = mock.calls.Package
	lockOutputPortMockPackage.RUnlock()
	return calls
}

// Service calls ServiceFunc.
func (mock *OutputPortMock) Service() (io.Reader, error) {
	if mock.ServiceFunc == nil {
		panic("OutputPortMock.ServiceFunc: method is nil but OutputPort.Service was just called")
	}
	callInfo := struct {
	}{}
	lockOutputPortMockService.Lock()
	mock.calls.Service = append(mock.calls.Service, callInfo)
	lockOutputPortMockService.Unlock()
	return mock.ServiceFunc()
}

// ServiceCalls gets all the calls that were made to Service.
// Check the length with:
//     len(mockedOutputPort.ServiceCalls())
func (mock *OutputPortMock) ServiceCalls() []struct {
} {
	var calls []struct {
	}
	lockOutputPortMockService.RLock()
	calls = mock.calls.Service
	lockOutputPortMockService.RUnlock()
	return calls
}

// Show calls ShowFunc.
func (mock *OutputPortMock) Show(showable port.Showable) (io.Reader, error) {
	if mock.ShowFunc == nil {
		panic("OutputPortMock.ShowFunc: method is nil but OutputPort.Show was just called")
	}
	callInfo := struct {
		Showable port.Showable
	}{
		Showable: showable,
	}
	lockOutputPortMockShow.Lock()
	mock.calls.Show = append(mock.calls.Show, callInfo)
	lockOutputPortMockShow.Unlock()
	return mock.ShowFunc(showable)
}

// ShowCalls gets all the calls that were made to Show.
// Check the length with:
//     len(mockedOutputPort.ShowCalls())
func (mock *OutputPortMock) ShowCalls() []struct {
	Showable port.Showable
} {
	var calls []struct {
		Showable port.Showable
	}
	lockOutputPortMockShow.RLock()
	calls = mock.calls.Show
	lockOutputPortMockShow.RUnlock()
	return calls
}
