// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mockport

import (
	"github.com/golang/protobuf/proto"
	"github.com/jhump/protoreflect/desc"
	"github.com/ktr0731/evans/entity"
	"github.com/ktr0731/evans/usecase/port"
	"io"
	"sync"
)

var (
	lockInputPortMockCall     sync.RWMutex
	lockInputPortMockDescribe sync.RWMutex
	lockInputPortMockHeader   sync.RWMutex
	lockInputPortMockPackage  sync.RWMutex
	lockInputPortMockService  sync.RWMutex
	lockInputPortMockShow     sync.RWMutex
)

// Ensure, that InputPortMock does implement InputPort.
// If this is not the case, regenerate this file with moq.
var _ port.InputPort = &InputPortMock{}

// InputPortMock is a mock implementation of InputPort.
//
//     func TestSomethingThatUsesInputPort(t *testing.T) {
//
//         // make and configure a mocked InputPort
//         mockedInputPort := &InputPortMock{
//             CallFunc: func(in1 *port.CallParams) (io.Reader, error) {
// 	               panic("mock out the Call method")
//             },
//             DescribeFunc: func(in1 *port.DescribeParams) (io.Reader, error) {
// 	               panic("mock out the Describe method")
//             },
//             HeaderFunc: func(in1 *port.HeaderParams) (io.Reader, error) {
// 	               panic("mock out the Header method")
//             },
//             PackageFunc: func(in1 *port.PackageParams) (io.Reader, error) {
// 	               panic("mock out the Package method")
//             },
//             ServiceFunc: func(in1 *port.ServiceParams) (io.Reader, error) {
// 	               panic("mock out the Service method")
//             },
//             ShowFunc: func(in1 *port.ShowParams) (io.Reader, error) {
// 	               panic("mock out the Show method")
//             },
//         }
//
//         // use mockedInputPort in code that requires InputPort
//         // and then make assertions.
//
//     }
type InputPortMock struct {
	// CallFunc mocks the Call method.
	CallFunc func(in1 *port.CallParams) (io.Reader, error)

	// DescribeFunc mocks the Describe method.
	DescribeFunc func(in1 *port.DescribeParams) (io.Reader, error)

	// HeaderFunc mocks the Header method.
	HeaderFunc func(in1 *port.HeaderParams) (io.Reader, error)

	// PackageFunc mocks the Package method.
	PackageFunc func(in1 *port.PackageParams) (io.Reader, error)

	// ServiceFunc mocks the Service method.
	ServiceFunc func(in1 *port.ServiceParams) (io.Reader, error)

	// ShowFunc mocks the Show method.
	ShowFunc func(in1 *port.ShowParams) (io.Reader, error)

	// calls tracks calls to the methods.
	calls struct {
		// Call holds details about calls to the Call method.
		Call []struct {
			// In1 is the in1 argument value.
			In1 *port.CallParams
		}
		// Describe holds details about calls to the Describe method.
		Describe []struct {
			// In1 is the in1 argument value.
			In1 *port.DescribeParams
		}
		// Header holds details about calls to the Header method.
		Header []struct {
			// In1 is the in1 argument value.
			In1 *port.HeaderParams
		}
		// Package holds details about calls to the Package method.
		Package []struct {
			// In1 is the in1 argument value.
			In1 *port.PackageParams
		}
		// Service holds details about calls to the Service method.
		Service []struct {
			// In1 is the in1 argument value.
			In1 *port.ServiceParams
		}
		// Show holds details about calls to the Show method.
		Show []struct {
			// In1 is the in1 argument value.
			In1 *port.ShowParams
		}
	}
}

// Call calls CallFunc.
func (mock *InputPortMock) Call(in1 *port.CallParams) (io.Reader, error) {
	if mock.CallFunc == nil {
		panic("InputPortMock.CallFunc: method is nil but InputPort.Call was just called")
	}
	callInfo := struct {
		In1 *port.CallParams
	}{
		In1: in1,
	}
	lockInputPortMockCall.Lock()
	mock.calls.Call = append(mock.calls.Call, callInfo)
	lockInputPortMockCall.Unlock()
	return mock.CallFunc(in1)
}

// CallCalls gets all the calls that were made to Call.
// Check the length with:
//     len(mockedInputPort.CallCalls())
func (mock *InputPortMock) CallCalls() []struct {
	In1 *port.CallParams
} {
	var calls []struct {
		In1 *port.CallParams
	}
	lockInputPortMockCall.RLock()
	calls = mock.calls.Call
	lockInputPortMockCall.RUnlock()
	return calls
}

// Describe calls DescribeFunc.
func (mock *InputPortMock) Describe(in1 *port.DescribeParams) (io.Reader, error) {
	if mock.DescribeFunc == nil {
		panic("InputPortMock.DescribeFunc: method is nil but InputPort.Describe was just called")
	}
	callInfo := struct {
		In1 *port.DescribeParams
	}{
		In1: in1,
	}
	lockInputPortMockDescribe.Lock()
	mock.calls.Describe = append(mock.calls.Describe, callInfo)
	lockInputPortMockDescribe.Unlock()
	return mock.DescribeFunc(in1)
}

// DescribeCalls gets all the calls that were made to Describe.
// Check the length with:
//     len(mockedInputPort.DescribeCalls())
func (mock *InputPortMock) DescribeCalls() []struct {
	In1 *port.DescribeParams
} {
	var calls []struct {
		In1 *port.DescribeParams
	}
	lockInputPortMockDescribe.RLock()
	calls = mock.calls.Describe
	lockInputPortMockDescribe.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *InputPortMock) Header(in1 *port.HeaderParams) (io.Reader, error) {
	if mock.HeaderFunc == nil {
		panic("InputPortMock.HeaderFunc: method is nil but InputPort.Header was just called")
	}
	callInfo := struct {
		In1 *port.HeaderParams
	}{
		In1: in1,
	}
	lockInputPortMockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	lockInputPortMockHeader.Unlock()
	return mock.HeaderFunc(in1)
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//     len(mockedInputPort.HeaderCalls())
func (mock *InputPortMock) HeaderCalls() []struct {
	In1 *port.HeaderParams
} {
	var calls []struct {
		In1 *port.HeaderParams
	}
	lockInputPortMockHeader.RLock()
	calls = mock.calls.Header
	lockInputPortMockHeader.RUnlock()
	return calls
}

// Package calls PackageFunc.
func (mock *InputPortMock) Package(in1 *port.PackageParams) (io.Reader, error) {
	if mock.PackageFunc == nil {
		panic("InputPortMock.PackageFunc: method is nil but InputPort.Package was just called")
	}
	callInfo := struct {
		In1 *port.PackageParams
	}{
		In1: in1,
	}
	lockInputPortMockPackage.Lock()
	mock.calls.Package = append(mock.calls.Package, callInfo)
	lockInputPortMockPackage.Unlock()
	return mock.PackageFunc(in1)
}

// PackageCalls gets all the calls that were made to Package.
// Check the length with:
//     len(mockedInputPort.PackageCalls())
func (mock *InputPortMock) PackageCalls() []struct {
	In1 *port.PackageParams
} {
	var calls []struct {
		In1 *port.PackageParams
	}
	lockInputPortMockPackage.RLock()
	calls = mock.calls.Package
	lockInputPortMockPackage.RUnlock()
	return calls
}

// Service calls ServiceFunc.
func (mock *InputPortMock) Service(in1 *port.ServiceParams) (io.Reader, error) {
	if mock.ServiceFunc == nil {
		panic("InputPortMock.ServiceFunc: method is nil but InputPort.Service was just called")
	}
	callInfo := struct {
		In1 *port.ServiceParams
	}{
		In1: in1,
	}
	lockInputPortMockService.Lock()
	mock.calls.Service = append(mock.calls.Service, callInfo)
	lockInputPortMockService.Unlock()
	return mock.ServiceFunc(in1)
}

// ServiceCalls gets all the calls that were made to Service.
// Check the length with:
//     len(mockedInputPort.ServiceCalls())
func (mock *InputPortMock) ServiceCalls() []struct {
	In1 *port.ServiceParams
} {
	var calls []struct {
		In1 *port.ServiceParams
	}
	lockInputPortMockService.RLock()
	calls = mock.calls.Service
	lockInputPortMockService.RUnlock()
	return calls
}

// Show calls ShowFunc.
func (mock *InputPortMock) Show(in1 *port.ShowParams) (io.Reader, error) {
	if mock.ShowFunc == nil {
		panic("InputPortMock.ShowFunc: method is nil but InputPort.Show was just called")
	}
	callInfo := struct {
		In1 *port.ShowParams
	}{
		In1: in1,
	}
	lockInputPortMockShow.Lock()
	mock.calls.Show = append(mock.calls.Show, callInfo)
	lockInputPortMockShow.Unlock()
	return mock.ShowFunc(in1)
}

// ShowCalls gets all the calls that were made to Show.
// Check the length with:
//     len(mockedInputPort.ShowCalls())
func (mock *InputPortMock) ShowCalls() []struct {
	In1 *port.ShowParams
} {
	var calls []struct {
		In1 *port.ShowParams
	}
	lockInputPortMockShow.RLock()
	calls = mock.calls.Show
	lockInputPortMockShow.RUnlock()
	return calls
}

var (
	lockShowableMockShow sync.RWMutex
)

// Ensure, that ShowableMock does implement Showable.
// If this is not the case, regenerate this file with moq.
var _ port.Showable = &ShowableMock{}

// ShowableMock is a mock implementation of Showable.
//
//     func TestSomethingThatUsesShowable(t *testing.T) {
//
//         // make and configure a mocked Showable
//         mockedShowable := &ShowableMock{
//             ShowFunc: func() string {
// 	               panic("mock out the Show method")
//             },
//         }
//
//         // use mockedShowable in code that requires Showable
//         // and then make assertions.
//
//     }
type ShowableMock struct {
	// ShowFunc mocks the Show method.
	ShowFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Show holds details about calls to the Show method.
		Show []struct {
		}
	}
}

// Show calls ShowFunc.
func (mock *ShowableMock) Show() string {
	if mock.ShowFunc == nil {
		panic("ShowableMock.ShowFunc: method is nil but Showable.Show was just called")
	}
	callInfo := struct {
	}{}
	lockShowableMockShow.Lock()
	mock.calls.Show = append(mock.calls.Show, callInfo)
	lockShowableMockShow.Unlock()
	return mock.ShowFunc()
}

// ShowCalls gets all the calls that were made to Show.
// Check the length with:
//     len(mockedShowable.ShowCalls())
func (mock *ShowableMock) ShowCalls() []struct {
} {
	var calls []struct {
	}
	lockShowableMockShow.RLock()
	calls = mock.calls.Show
	lockShowableMockShow.RUnlock()
	return calls
}

var (
	lockInputterMockInput sync.RWMutex
)

// Ensure, that InputterMock does implement Inputter.
// If this is not the case, regenerate this file with moq.
var _ port.Inputter = &InputterMock{}

// InputterMock is a mock implementation of Inputter.
//
//     func TestSomethingThatUsesInputter(t *testing.T) {
//
//         // make and configure a mocked Inputter
//         mockedInputter := &InputterMock{
//             InputFunc: func(req *desc.MessageDescriptor) (proto.Message, error) {
// 	               panic("mock out the Input method")
//             },
//         }
//
//         // use mockedInputter in code that requires Inputter
//         // and then make assertions.
//
//     }
type InputterMock struct {
	// InputFunc mocks the Input method.
	InputFunc func(req *desc.MessageDescriptor) (proto.Message, error)

	// calls tracks calls to the methods.
	calls struct {
		// Input holds details about calls to the Input method.
		Input []struct {
			// Req is the req argument value.
			Req *desc.MessageDescriptor
		}
	}
}

// Input calls InputFunc.
func (mock *InputterMock) Input(req *desc.MessageDescriptor) (proto.Message, error) {
	if mock.InputFunc == nil {
		panic("InputterMock.InputFunc: method is nil but Inputter.Input was just called")
	}
	callInfo := struct {
		Req *desc.MessageDescriptor
	}{
		Req: req,
	}
	lockInputterMockInput.Lock()
	mock.calls.Input = append(mock.calls.Input, callInfo)
	lockInputterMockInput.Unlock()
	return mock.InputFunc(req)
}

// InputCalls gets all the calls that were made to Input.
// Check the length with:
//     len(mockedInputter.InputCalls())
func (mock *InputterMock) InputCalls() []struct {
	Req *desc.MessageDescriptor
} {
	var calls []struct {
		Req *desc.MessageDescriptor
	}
	lockInputterMockInput.RLock()
	calls = mock.calls.Input
	lockInputterMockInput.RUnlock()
	return calls
}

var (
	lockOutputPortMockCall     sync.RWMutex
	lockOutputPortMockDescribe sync.RWMutex
	lockOutputPortMockHeader   sync.RWMutex
	lockOutputPortMockPackage  sync.RWMutex
	lockOutputPortMockService  sync.RWMutex
	lockOutputPortMockShow     sync.RWMutex
)

// Ensure, that OutputPortMock does implement OutputPort.
// If this is not the case, regenerate this file with moq.
var _ port.OutputPort = &OutputPortMock{}

// OutputPortMock is a mock implementation of OutputPort.
//
//     func TestSomethingThatUsesOutputPort(t *testing.T) {
//
//         // make and configure a mocked OutputPort
//         mockedOutputPort := &OutputPortMock{
//             CallFunc: func(res proto.Message) (io.Reader, error) {
// 	               panic("mock out the Call method")
//             },
//             DescribeFunc: func(showable port.Showable) (io.Reader, error) {
// 	               panic("mock out the Describe method")
//             },
//             HeaderFunc: func() (io.Reader, error) {
// 	               panic("mock out the Header method")
//             },
//             PackageFunc: func() (io.Reader, error) {
// 	               panic("mock out the Package method")
//             },
//             ServiceFunc: func() (io.Reader, error) {
// 	               panic("mock out the Service method")
//             },
//             ShowFunc: func(showable port.Showable) (io.Reader, error) {
// 	               panic("mock out the Show method")
//             },
//         }
//
//         // use mockedOutputPort in code that requires OutputPort
//         // and then make assertions.
//
//     }
type OutputPortMock struct {
	// CallFunc mocks the Call method.
	CallFunc func(res proto.Message) (io.Reader, error)

	// DescribeFunc mocks the Describe method.
	DescribeFunc func(showable port.Showable) (io.Reader, error)

	// HeaderFunc mocks the Header method.
	HeaderFunc func() (io.Reader, error)

	// PackageFunc mocks the Package method.
	PackageFunc func() (io.Reader, error)

	// ServiceFunc mocks the Service method.
	ServiceFunc func() (io.Reader, error)

	// ShowFunc mocks the Show method.
	ShowFunc func(showable port.Showable) (io.Reader, error)

	// calls tracks calls to the methods.
	calls struct {
		// Call holds details about calls to the Call method.
		Call []struct {
			// Res is the res argument value.
			Res proto.Message
		}
		// Describe holds details about calls to the Describe method.
		Describe []struct {
			// Showable is the showable argument value.
			Showable port.Showable
		}
		// Header holds details about calls to the Header method.
		Header []struct {
		}
		// Package holds details about calls to the Package method.
		Package []struct {
		}
		// Service holds details about calls to the Service method.
		Service []struct {
		}
		// Show holds details about calls to the Show method.
		Show []struct {
			// Showable is the showable argument value.
			Showable port.Showable
		}
	}
}

// Call calls CallFunc.
func (mock *OutputPortMock) Call(res proto.Message) (io.Reader, error) {
	if mock.CallFunc == nil {
		panic("OutputPortMock.CallFunc: method is nil but OutputPort.Call was just called")
	}
	callInfo := struct {
		Res proto.Message
	}{
		Res: res,
	}
	lockOutputPortMockCall.Lock()
	mock.calls.Call = append(mock.calls.Call, callInfo)
	lockOutputPortMockCall.Unlock()
	return mock.CallFunc(res)
}

// CallCalls gets all the calls that were made to Call.
// Check the length with:
//     len(mockedOutputPort.CallCalls())
func (mock *OutputPortMock) CallCalls() []struct {
	Res proto.Message
} {
	var calls []struct {
		Res proto.Message
	}
	lockOutputPortMockCall.RLock()
	calls = mock.calls.Call
	lockOutputPortMockCall.RUnlock()
	return calls
}

// Describe calls DescribeFunc.
func (mock *OutputPortMock) Describe(showable port.Showable) (io.Reader, error) {
	if mock.DescribeFunc == nil {
		panic("OutputPortMock.DescribeFunc: method is nil but OutputPort.Describe was just called")
	}
	callInfo := struct {
		Showable port.Showable
	}{
		Showable: showable,
	}
	lockOutputPortMockDescribe.Lock()
	mock.calls.Describe = append(mock.calls.Describe, callInfo)
	lockOutputPortMockDescribe.Unlock()
	return mock.DescribeFunc(showable)
}

// DescribeCalls gets all the calls that were made to Describe.
// Check the length with:
//     len(mockedOutputPort.DescribeCalls())
func (mock *OutputPortMock) DescribeCalls() []struct {
	Showable port.Showable
} {
	var calls []struct {
		Showable port.Showable
	}
	lockOutputPortMockDescribe.RLock()
	calls = mock.calls.Describe
	lockOutputPortMockDescribe.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *OutputPortMock) Header() (io.Reader, error) {
	if mock.HeaderFunc == nil {
		panic("OutputPortMock.HeaderFunc: method is nil but OutputPort.Header was just called")
	}
	callInfo := struct {
	}{}
	lockOutputPortMockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	lockOutputPortMockHeader.Unlock()
	return mock.HeaderFunc()
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//     len(mockedOutputPort.HeaderCalls())
func (mock *OutputPortMock) HeaderCalls() []struct {
} {
	var calls []struct {
	}
	lockOutputPortMockHeader.RLock()
	calls = mock.calls.Header
	lockOutputPortMockHeader.RUnlock()
	return calls
}

// Package calls PackageFunc.
func (mock *OutputPortMock) Package() (io.Reader, error) {
	if mock.PackageFunc == nil {
		panic("OutputPortMock.PackageFunc: method is nil but OutputPort.Package was just called")
	}
	callInfo := struct {
	}{}
	lockOutputPortMockPackage.Lock()
	mock.calls.Package = append(mock.calls.Package, callInfo)
	lockOutputPortMockPackage.Unlock()
	return mock.PackageFunc()
}

// PackageCalls gets all the calls that were made to Package.
// Check the length with:
//     len(mockedOutputPort.PackageCalls())
func (mock *OutputPortMock) PackageCalls() []struct {
} {
	var calls []struct {
	}
	lockOutputPortMockPackage.RLock()
	calls = mock.calls.Package
	lockOutputPortMockPackage.RUnlock()
	return calls
}

// Service calls ServiceFunc.
func (mock *OutputPortMock) Service() (io.Reader, error) {
	if mock.ServiceFunc == nil {
		panic("OutputPortMock.ServiceFunc: method is nil but OutputPort.Service was just called")
	}
	callInfo := struct {
	}{}
	lockOutputPortMockService.Lock()
	mock.calls.Service = append(mock.calls.Service, callInfo)
	lockOutputPortMockService.Unlock()
	return mock.ServiceFunc()
}

// ServiceCalls gets all the calls that were made to Service.
// Check the length with:
//     len(mockedOutputPort.ServiceCalls())
func (mock *OutputPortMock) ServiceCalls() []struct {
} {
	var calls []struct {
	}
	lockOutputPortMockService.RLock()
	calls = mock.calls.Service
	lockOutputPortMockService.RUnlock()
	return calls
}

// Show calls ShowFunc.
func (mock *OutputPortMock) Show(showable port.Showable) (io.Reader, error) {
	if mock.ShowFunc == nil {
		panic("OutputPortMock.ShowFunc: method is nil but OutputPort.Show was just called")
	}
	callInfo := struct {
		Showable port.Showable
	}{
		Showable: showable,
	}
	lockOutputPortMockShow.Lock()
	mock.calls.Show = append(mock.calls.Show, callInfo)
	lockOutputPortMockShow.Unlock()
	return mock.ShowFunc(showable)
}

// ShowCalls gets all the calls that were made to Show.
// Check the length with:
//     len(mockedOutputPort.ShowCalls())
func (mock *OutputPortMock) ShowCalls() []struct {
	Showable port.Showable
} {
	var calls []struct {
		Showable port.Showable
	}
	lockOutputPortMockShow.RLock()
	calls = mock.calls.Show
	lockOutputPortMockShow.RUnlock()
	return calls
}

var (
	lockDynamicBuilderMockNewMessage sync.RWMutex
)

// Ensure, that DynamicBuilderMock does implement DynamicBuilder.
// If this is not the case, regenerate this file with moq.
var _ port.DynamicBuilder = &DynamicBuilderMock{}

// DynamicBuilderMock is a mock implementation of DynamicBuilder.
//
//     func TestSomethingThatUsesDynamicBuilder(t *testing.T) {
//
//         // make and configure a mocked DynamicBuilder
//         mockedDynamicBuilder := &DynamicBuilderMock{
//             NewMessageFunc: func(m entity.Message) proto.Message {
// 	               panic("mock out the NewMessage method")
//             },
//         }
//
//         // use mockedDynamicBuilder in code that requires DynamicBuilder
//         // and then make assertions.
//
//     }
type DynamicBuilderMock struct {
	// NewMessageFunc mocks the NewMessage method.
	NewMessageFunc func(m entity.Message) proto.Message

	// calls tracks calls to the methods.
	calls struct {
		// NewMessage holds details about calls to the NewMessage method.
		NewMessage []struct {
			// M is the m argument value.
			M entity.Message
		}
	}
}

// NewMessage calls NewMessageFunc.
func (mock *DynamicBuilderMock) NewMessage(m entity.Message) proto.Message {
	if mock.NewMessageFunc == nil {
		panic("DynamicBuilderMock.NewMessageFunc: method is nil but DynamicBuilder.NewMessage was just called")
	}
	callInfo := struct {
		M entity.Message
	}{
		M: m,
	}
	lockDynamicBuilderMockNewMessage.Lock()
	mock.calls.NewMessage = append(mock.calls.NewMessage, callInfo)
	lockDynamicBuilderMockNewMessage.Unlock()
	return mock.NewMessageFunc(m)
}

// NewMessageCalls gets all the calls that were made to NewMessage.
// Check the length with:
//     len(mockedDynamicBuilder.NewMessageCalls())
func (mock *DynamicBuilderMock) NewMessageCalls() []struct {
	M entity.Message
} {
	var calls []struct {
		M entity.Message
	}
	lockDynamicBuilderMockNewMessage.RLock()
	calls = mock.calls.NewMessage
	lockDynamicBuilderMockNewMessage.RUnlock()
	return calls
}
