// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package entity

import (
	"google.golang.org/grpc"
	"sync"
)

var (
	lockFieldMockFQRN       sync.RWMutex
	lockFieldMockFieldName  sync.RWMutex
	lockFieldMockIsRepeated sync.RWMutex
	lockFieldMockPBType     sync.RWMutex
	lockFieldMockType       sync.RWMutex
)

// FieldMock is a mock implementation of Field.
//
//     func TestSomethingThatUsesField(t *testing.T) {
//
//         // make and configure a mocked Field
//         mockedField := &FieldMock{
//             FQRNFunc: func() string {
// 	               panic("TODO: mock out the FQRN method")
//             },
//             FieldNameFunc: func() string {
// 	               panic("TODO: mock out the FieldName method")
//             },
//             IsRepeatedFunc: func() bool {
// 	               panic("TODO: mock out the IsRepeated method")
//             },
//             PBTypeFunc: func() string {
// 	               panic("TODO: mock out the PBType method")
//             },
//             TypeFunc: func() FieldType {
// 	               panic("TODO: mock out the Type method")
//             },
//         }
//
//         // TODO: use mockedField in code that requires Field
//         //       and then make assertions.
//
//     }
type FieldMock struct {
	// FQRNFunc mocks the FQRN method.
	FQRNFunc func() string

	// FieldNameFunc mocks the FieldName method.
	FieldNameFunc func() string

	// IsRepeatedFunc mocks the IsRepeated method.
	IsRepeatedFunc func() bool

	// PBTypeFunc mocks the PBType method.
	PBTypeFunc func() string

	// TypeFunc mocks the Type method.
	TypeFunc func() FieldType

	// calls tracks calls to the methods.
	calls struct {
		// FQRN holds details about calls to the FQRN method.
		FQRN []struct {
		}
		// FieldName holds details about calls to the FieldName method.
		FieldName []struct {
		}
		// IsRepeated holds details about calls to the IsRepeated method.
		IsRepeated []struct {
		}
		// PBType holds details about calls to the PBType method.
		PBType []struct {
		}
		// Type holds details about calls to the Type method.
		Type []struct {
		}
	}
}

// FQRN calls FQRNFunc.
func (mock *FieldMock) FQRN() string {
	if mock.FQRNFunc == nil {
		panic("FieldMock.FQRNFunc: method is nil but Field.FQRN was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockFQRN.Lock()
	mock.calls.FQRN = append(mock.calls.FQRN, callInfo)
	lockFieldMockFQRN.Unlock()
	return mock.FQRNFunc()
}

// FQRNCalls gets all the calls that were made to FQRN.
// Check the length with:
//     len(mockedField.FQRNCalls())
func (mock *FieldMock) FQRNCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockFQRN.RLock()
	calls = mock.calls.FQRN
	lockFieldMockFQRN.RUnlock()
	return calls
}

// FieldName calls FieldNameFunc.
func (mock *FieldMock) FieldName() string {
	if mock.FieldNameFunc == nil {
		panic("FieldMock.FieldNameFunc: method is nil but Field.FieldName was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockFieldName.Lock()
	mock.calls.FieldName = append(mock.calls.FieldName, callInfo)
	lockFieldMockFieldName.Unlock()
	return mock.FieldNameFunc()
}

// FieldNameCalls gets all the calls that were made to FieldName.
// Check the length with:
//     len(mockedField.FieldNameCalls())
func (mock *FieldMock) FieldNameCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockFieldName.RLock()
	calls = mock.calls.FieldName
	lockFieldMockFieldName.RUnlock()
	return calls
}

// IsRepeated calls IsRepeatedFunc.
func (mock *FieldMock) IsRepeated() bool {
	if mock.IsRepeatedFunc == nil {
		panic("FieldMock.IsRepeatedFunc: method is nil but Field.IsRepeated was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockIsRepeated.Lock()
	mock.calls.IsRepeated = append(mock.calls.IsRepeated, callInfo)
	lockFieldMockIsRepeated.Unlock()
	return mock.IsRepeatedFunc()
}

// IsRepeatedCalls gets all the calls that were made to IsRepeated.
// Check the length with:
//     len(mockedField.IsRepeatedCalls())
func (mock *FieldMock) IsRepeatedCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockIsRepeated.RLock()
	calls = mock.calls.IsRepeated
	lockFieldMockIsRepeated.RUnlock()
	return calls
}

// PBType calls PBTypeFunc.
func (mock *FieldMock) PBType() string {
	if mock.PBTypeFunc == nil {
		panic("FieldMock.PBTypeFunc: method is nil but Field.PBType was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockPBType.Lock()
	mock.calls.PBType = append(mock.calls.PBType, callInfo)
	lockFieldMockPBType.Unlock()
	return mock.PBTypeFunc()
}

// PBTypeCalls gets all the calls that were made to PBType.
// Check the length with:
//     len(mockedField.PBTypeCalls())
func (mock *FieldMock) PBTypeCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockPBType.RLock()
	calls = mock.calls.PBType
	lockFieldMockPBType.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *FieldMock) Type() FieldType {
	if mock.TypeFunc == nil {
		panic("FieldMock.TypeFunc: method is nil but Field.Type was just called")
	}
	callInfo := struct {
	}{}
	lockFieldMockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	lockFieldMockType.Unlock()
	return mock.TypeFunc()
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//     len(mockedField.TypeCalls())
func (mock *FieldMock) TypeCalls() []struct {
} {
	var calls []struct {
	}
	lockFieldMockType.RLock()
	calls = mock.calls.Type
	lockFieldMockType.RUnlock()
	return calls
}

var (
	lockRPCMockFQRN              sync.RWMutex
	lockRPCMockIsClientStreaming sync.RWMutex
	lockRPCMockIsServerStreaming sync.RWMutex
	lockRPCMockName              sync.RWMutex
	lockRPCMockRequestMessage    sync.RWMutex
	lockRPCMockResponseMessage   sync.RWMutex
	lockRPCMockStreamDesc        sync.RWMutex
)

// RPCMock is a mock implementation of RPC.
//
//     func TestSomethingThatUsesRPC(t *testing.T) {
//
//         // make and configure a mocked RPC
//         mockedRPC := &RPCMock{
//             FQRNFunc: func() string {
// 	               panic("TODO: mock out the FQRN method")
//             },
//             IsClientStreamingFunc: func() bool {
// 	               panic("TODO: mock out the IsClientStreaming method")
//             },
//             IsServerStreamingFunc: func() bool {
// 	               panic("TODO: mock out the IsServerStreaming method")
//             },
//             NameFunc: func() string {
// 	               panic("TODO: mock out the Name method")
//             },
//             RequestMessageFunc: func() Message {
// 	               panic("TODO: mock out the RequestMessage method")
//             },
//             ResponseMessageFunc: func() Message {
// 	               panic("TODO: mock out the ResponseMessage method")
//             },
//             StreamDescFunc: func() *grpc.StreamDesc {
// 	               panic("TODO: mock out the StreamDesc method")
//             },
//         }
//
//         // TODO: use mockedRPC in code that requires RPC
//         //       and then make assertions.
//
//     }
type RPCMock struct {
	// FQRNFunc mocks the FQRN method.
	FQRNFunc func() string

	// IsClientStreamingFunc mocks the IsClientStreaming method.
	IsClientStreamingFunc func() bool

	// IsServerStreamingFunc mocks the IsServerStreaming method.
	IsServerStreamingFunc func() bool

	// NameFunc mocks the Name method.
	NameFunc func() string

	// RequestMessageFunc mocks the RequestMessage method.
	RequestMessageFunc func() Message

	// ResponseMessageFunc mocks the ResponseMessage method.
	ResponseMessageFunc func() Message

	// StreamDescFunc mocks the StreamDesc method.
	StreamDescFunc func() *grpc.StreamDesc

	// calls tracks calls to the methods.
	calls struct {
		// FQRN holds details about calls to the FQRN method.
		FQRN []struct {
		}
		// IsClientStreaming holds details about calls to the IsClientStreaming method.
		IsClientStreaming []struct {
		}
		// IsServerStreaming holds details about calls to the IsServerStreaming method.
		IsServerStreaming []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// RequestMessage holds details about calls to the RequestMessage method.
		RequestMessage []struct {
		}
		// ResponseMessage holds details about calls to the ResponseMessage method.
		ResponseMessage []struct {
		}
		// StreamDesc holds details about calls to the StreamDesc method.
		StreamDesc []struct {
		}
	}
}

// FQRN calls FQRNFunc.
func (mock *RPCMock) FQRN() string {
	if mock.FQRNFunc == nil {
		panic("RPCMock.FQRNFunc: method is nil but RPC.FQRN was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockFQRN.Lock()
	mock.calls.FQRN = append(mock.calls.FQRN, callInfo)
	lockRPCMockFQRN.Unlock()
	return mock.FQRNFunc()
}

// FQRNCalls gets all the calls that were made to FQRN.
// Check the length with:
//     len(mockedRPC.FQRNCalls())
func (mock *RPCMock) FQRNCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockFQRN.RLock()
	calls = mock.calls.FQRN
	lockRPCMockFQRN.RUnlock()
	return calls
}

// IsClientStreaming calls IsClientStreamingFunc.
func (mock *RPCMock) IsClientStreaming() bool {
	if mock.IsClientStreamingFunc == nil {
		panic("RPCMock.IsClientStreamingFunc: method is nil but RPC.IsClientStreaming was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockIsClientStreaming.Lock()
	mock.calls.IsClientStreaming = append(mock.calls.IsClientStreaming, callInfo)
	lockRPCMockIsClientStreaming.Unlock()
	return mock.IsClientStreamingFunc()
}

// IsClientStreamingCalls gets all the calls that were made to IsClientStreaming.
// Check the length with:
//     len(mockedRPC.IsClientStreamingCalls())
func (mock *RPCMock) IsClientStreamingCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockIsClientStreaming.RLock()
	calls = mock.calls.IsClientStreaming
	lockRPCMockIsClientStreaming.RUnlock()
	return calls
}

// IsServerStreaming calls IsServerStreamingFunc.
func (mock *RPCMock) IsServerStreaming() bool {
	if mock.IsServerStreamingFunc == nil {
		panic("RPCMock.IsServerStreamingFunc: method is nil but RPC.IsServerStreaming was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockIsServerStreaming.Lock()
	mock.calls.IsServerStreaming = append(mock.calls.IsServerStreaming, callInfo)
	lockRPCMockIsServerStreaming.Unlock()
	return mock.IsServerStreamingFunc()
}

// IsServerStreamingCalls gets all the calls that were made to IsServerStreaming.
// Check the length with:
//     len(mockedRPC.IsServerStreamingCalls())
func (mock *RPCMock) IsServerStreamingCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockIsServerStreaming.RLock()
	calls = mock.calls.IsServerStreaming
	lockRPCMockIsServerStreaming.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *RPCMock) Name() string {
	if mock.NameFunc == nil {
		panic("RPCMock.NameFunc: method is nil but RPC.Name was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	lockRPCMockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedRPC.NameCalls())
func (mock *RPCMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockName.RLock()
	calls = mock.calls.Name
	lockRPCMockName.RUnlock()
	return calls
}

// RequestMessage calls RequestMessageFunc.
func (mock *RPCMock) RequestMessage() Message {
	if mock.RequestMessageFunc == nil {
		panic("RPCMock.RequestMessageFunc: method is nil but RPC.RequestMessage was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockRequestMessage.Lock()
	mock.calls.RequestMessage = append(mock.calls.RequestMessage, callInfo)
	lockRPCMockRequestMessage.Unlock()
	return mock.RequestMessageFunc()
}

// RequestMessageCalls gets all the calls that were made to RequestMessage.
// Check the length with:
//     len(mockedRPC.RequestMessageCalls())
func (mock *RPCMock) RequestMessageCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockRequestMessage.RLock()
	calls = mock.calls.RequestMessage
	lockRPCMockRequestMessage.RUnlock()
	return calls
}

// ResponseMessage calls ResponseMessageFunc.
func (mock *RPCMock) ResponseMessage() Message {
	if mock.ResponseMessageFunc == nil {
		panic("RPCMock.ResponseMessageFunc: method is nil but RPC.ResponseMessage was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockResponseMessage.Lock()
	mock.calls.ResponseMessage = append(mock.calls.ResponseMessage, callInfo)
	lockRPCMockResponseMessage.Unlock()
	return mock.ResponseMessageFunc()
}

// ResponseMessageCalls gets all the calls that were made to ResponseMessage.
// Check the length with:
//     len(mockedRPC.ResponseMessageCalls())
func (mock *RPCMock) ResponseMessageCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockResponseMessage.RLock()
	calls = mock.calls.ResponseMessage
	lockRPCMockResponseMessage.RUnlock()
	return calls
}

// StreamDesc calls StreamDescFunc.
func (mock *RPCMock) StreamDesc() *grpc.StreamDesc {
	if mock.StreamDescFunc == nil {
		panic("RPCMock.StreamDescFunc: method is nil but RPC.StreamDesc was just called")
	}
	callInfo := struct {
	}{}
	lockRPCMockStreamDesc.Lock()
	mock.calls.StreamDesc = append(mock.calls.StreamDesc, callInfo)
	lockRPCMockStreamDesc.Unlock()
	return mock.StreamDescFunc()
}

// StreamDescCalls gets all the calls that were made to StreamDesc.
// Check the length with:
//     len(mockedRPC.StreamDescCalls())
func (mock *RPCMock) StreamDescCalls() []struct {
} {
	var calls []struct {
	}
	lockRPCMockStreamDesc.RLock()
	calls = mock.calls.StreamDesc
	lockRPCMockStreamDesc.RUnlock()
	return calls
}

var (
	lockServiceMockFQRN sync.RWMutex
	lockServiceMockName sync.RWMutex
	lockServiceMockRPCs sync.RWMutex
)

// ServiceMock is a mock implementation of Service.
//
//     func TestSomethingThatUsesService(t *testing.T) {
//
//         // make and configure a mocked Service
//         mockedService := &ServiceMock{
//             FQRNFunc: func() string {
// 	               panic("TODO: mock out the FQRN method")
//             },
//             NameFunc: func() string {
// 	               panic("TODO: mock out the Name method")
//             },
//             RPCsFunc: func() []RPC {
// 	               panic("TODO: mock out the RPCs method")
//             },
//         }
//
//         // TODO: use mockedService in code that requires Service
//         //       and then make assertions.
//
//     }
type ServiceMock struct {
	// FQRNFunc mocks the FQRN method.
	FQRNFunc func() string

	// NameFunc mocks the Name method.
	NameFunc func() string

	// RPCsFunc mocks the RPCs method.
	RPCsFunc func() []RPC

	// calls tracks calls to the methods.
	calls struct {
		// FQRN holds details about calls to the FQRN method.
		FQRN []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// RPCs holds details about calls to the RPCs method.
		RPCs []struct {
		}
	}
}

// FQRN calls FQRNFunc.
func (mock *ServiceMock) FQRN() string {
	if mock.FQRNFunc == nil {
		panic("ServiceMock.FQRNFunc: method is nil but Service.FQRN was just called")
	}
	callInfo := struct {
	}{}
	lockServiceMockFQRN.Lock()
	mock.calls.FQRN = append(mock.calls.FQRN, callInfo)
	lockServiceMockFQRN.Unlock()
	return mock.FQRNFunc()
}

// FQRNCalls gets all the calls that were made to FQRN.
// Check the length with:
//     len(mockedService.FQRNCalls())
func (mock *ServiceMock) FQRNCalls() []struct {
} {
	var calls []struct {
	}
	lockServiceMockFQRN.RLock()
	calls = mock.calls.FQRN
	lockServiceMockFQRN.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *ServiceMock) Name() string {
	if mock.NameFunc == nil {
		panic("ServiceMock.NameFunc: method is nil but Service.Name was just called")
	}
	callInfo := struct {
	}{}
	lockServiceMockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	lockServiceMockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedService.NameCalls())
func (mock *ServiceMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	lockServiceMockName.RLock()
	calls = mock.calls.Name
	lockServiceMockName.RUnlock()
	return calls
}

// RPCs calls RPCsFunc.
func (mock *ServiceMock) RPCs() []RPC {
	if mock.RPCsFunc == nil {
		panic("ServiceMock.RPCsFunc: method is nil but Service.RPCs was just called")
	}
	callInfo := struct {
	}{}
	lockServiceMockRPCs.Lock()
	mock.calls.RPCs = append(mock.calls.RPCs, callInfo)
	lockServiceMockRPCs.Unlock()
	return mock.RPCsFunc()
}

// RPCsCalls gets all the calls that were made to RPCs.
// Check the length with:
//     len(mockedService.RPCsCalls())
func (mock *ServiceMock) RPCsCalls() []struct {
} {
	var calls []struct {
	}
	lockServiceMockRPCs.RLock()
	calls = mock.calls.RPCs
	lockServiceMockRPCs.RUnlock()
	return calls
}

var (
	lockMessageMockFields   sync.RWMutex
	lockMessageMockIsCycled sync.RWMutex
	lockMessageMockName     sync.RWMutex
)

// MessageMock is a mock implementation of Message.
//
//     func TestSomethingThatUsesMessage(t *testing.T) {
//
//         // make and configure a mocked Message
//         mockedMessage := &MessageMock{
//             FieldsFunc: func() []Field {
// 	               panic("TODO: mock out the Fields method")
//             },
//             IsCycledFunc: func() bool {
// 	               panic("TODO: mock out the IsCycled method")
//             },
//             NameFunc: func() string {
// 	               panic("TODO: mock out the Name method")
//             },
//         }
//
//         // TODO: use mockedMessage in code that requires Message
//         //       and then make assertions.
//
//     }
type MessageMock struct {
	// FieldsFunc mocks the Fields method.
	FieldsFunc func() []Field

	// IsCycledFunc mocks the IsCycled method.
	IsCycledFunc func() bool

	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Fields holds details about calls to the Fields method.
		Fields []struct {
		}
		// IsCycled holds details about calls to the IsCycled method.
		IsCycled []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
}

// Fields calls FieldsFunc.
func (mock *MessageMock) Fields() []Field {
	if mock.FieldsFunc == nil {
		panic("MessageMock.FieldsFunc: method is nil but Message.Fields was just called")
	}
	callInfo := struct {
	}{}
	lockMessageMockFields.Lock()
	mock.calls.Fields = append(mock.calls.Fields, callInfo)
	lockMessageMockFields.Unlock()
	return mock.FieldsFunc()
}

// FieldsCalls gets all the calls that were made to Fields.
// Check the length with:
//     len(mockedMessage.FieldsCalls())
func (mock *MessageMock) FieldsCalls() []struct {
} {
	var calls []struct {
	}
	lockMessageMockFields.RLock()
	calls = mock.calls.Fields
	lockMessageMockFields.RUnlock()
	return calls
}

// IsCycled calls IsCycledFunc.
func (mock *MessageMock) IsCycled() bool {
	if mock.IsCycledFunc == nil {
		panic("MessageMock.IsCycledFunc: method is nil but Message.IsCycled was just called")
	}
	callInfo := struct {
	}{}
	lockMessageMockIsCycled.Lock()
	mock.calls.IsCycled = append(mock.calls.IsCycled, callInfo)
	lockMessageMockIsCycled.Unlock()
	return mock.IsCycledFunc()
}

// IsCycledCalls gets all the calls that were made to IsCycled.
// Check the length with:
//     len(mockedMessage.IsCycledCalls())
func (mock *MessageMock) IsCycledCalls() []struct {
} {
	var calls []struct {
	}
	lockMessageMockIsCycled.RLock()
	calls = mock.calls.IsCycled
	lockMessageMockIsCycled.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *MessageMock) Name() string {
	if mock.NameFunc == nil {
		panic("MessageMock.NameFunc: method is nil but Message.Name was just called")
	}
	callInfo := struct {
	}{}
	lockMessageMockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	lockMessageMockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedMessage.NameCalls())
func (mock *MessageMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	lockMessageMockName.RLock()
	calls = mock.calls.Name
	lockMessageMockName.RUnlock()
	return calls
}
